Design & Implementation
for
PetQuest
Version <0.1>
 




Prepared by 
Group Name: GROUP C2
Lee Shing Hei
	1155183712
	1155183712@link.cuhk.edu.hk
	Sin Cheuk Yin
	1155193665
	1155193665@link.cuhk.edu.hk
	Tong King Laam
	1155194266
	1155194266@link.cuhk.edu.hk
	Wong Po Hing
	1155183715
	1155183715@link.cuhk.edu.hk
	Zhang Chak Fung
	1155192302
	1155192302@link.cuhk.edu.hk
	



Instructor:
	Dr. LAM Tak Kei
	Course:
	CSCI3100 Software Engineering
	Lab Section:
	

	Teaching Assistant:
	

	

	

	Date:
	11/3/2025
	













Contents
CONTENTS        2
1        INTRODUCTION        3
2        SYSTEM ARCHITECTURE        4
2.1        High-Level System Architecture        4
2.2        Client Layer        5
2.3        API        5
2.4        Service Layer        7
2.5        Data Layer        8
3        DATA MODELS        9
3.1        System Overview Diagrams        9
3.2        ER-Diagram        10
3.3        Data Flow Diagrams        10
3.4        Data Transformation Examples        
4        INTERFACE DESIGN        13
4.1        Communication Architecture        13
4.2        Data flow Operations        14
4.3        User Data Operations        14
5        COMPONENT DESIGN        16
5.1        Interaction Class        16
5.2        BattleSystem Class        27
5.3        Enemy Generator        33
5.4        Level Generator        36
6        USER INTERFACE DESIGN        39
7        ASSUMPTIONS        44
































1. Introduction
This document describes the design and implementation of PetQuest, a web-based application which provides pet simulation and roguelike adventure gameplay. PetQuest allows players to create and train pets, while promoting values like responsibility and empathy towards pets. PetQuest targets casual players, with initial release on desktop browsers using web standards (HTML5, CSS, JavaScript) and cloud-based server for database management.
To realise the requirements, we adopt Agile software development model, allowing iterative development, testing and refinement in short periods of cycles. This approach allows the software feedback to be flexible and responsive, which aligns with the project scope.
Aimed at developers and stakeholders, this document also provides a roadmap for the system design, architecture, component implementation and deployment.
































2. System Architecture
2.1 High Level System Architecture 
  

2.2 Client Layer
2.2.1 Pet Management Interface
* Description: The central hub where players interact with their pet and access gameplay options.
* Features:
   * Displays the player's pet as an animated sprite with real-time status updates (e.g., HP, energy, level).
   * Offers interactive buttons for pet actions (e.g., Feed, Play, Train).
   * Shows player status (e.g., username, time played) in a top panel.
* Visual Design: Uses pixel art for pet sprites, backgrounds, and buttons, creating a retro game feel.
2.2.2 Navigation and Game Screens
* Description: A collection of interconnected pages that guide players through the game.
* Screens:
   * Login Interface: Entry point for authentication or registration.
   * Pet Selection Interface: Allows new players to choose their starting pet.
   * Home Page: Main hub for pet interaction and game access.
   * Level Selection Page: Lists available quests for battle challenges.
   * Battle Page: Turn-based combat interface.
   * Battle Result Popup: Displays battle outcomes and rewards.
* Transitions: Smooth navigation between screens triggered by user actions (e.g., button clicks).
2.2.3 Dynamic Visuals and Animations
* Description: Enhances user engagement with real-time feedback.
* Examples:
   * Pet animations (e.g., jumping, wagging tail) when clicked or interacted with.
   * Battle animations (e.g., attack sprites, damage effects).
   * Backgrounds that change based on context (e.g., forest for home, cave for battles).
2.3 API
Key responsibilities:
* Authentication & authorization via JWT
* Request validation
* API rate limiting to prevent abuse
* Logging and monitoring
________________
2.3.1 JWT Authentication Middleware
   * Purpose: Verifies user identity
   * Functionality:
   * Extracts JWT token from Authorization header or cookies
   * Verifies token signature using secret key
   * Rejects unauthorized requests with appropriate status codes
   * Handles token expiration and refresh logic
   * Integration Points:
   * Interfaces with User Service to retrieve user information
   * Communicates with route handlers to enforce route-specific permissions
2.3.2 Routes
User & Auth Routes
   * Purpose: Manage user accounts and authentication
   * Endpoints:
   * /api/auth/register - Create new user account
   * /api/auth/login - Authenticate user
   * /api/auth/logout - Ends user session
   * /api/auth/me - Get current user profile
Pet Management Routes
   * Purpose: Handle pet creation and interactions
   * Endpoints:
   * /api/pets - Create pet (POST) or get all pets (GET)
   * /api/pets/:id - Get pet details
   * /api/pets/:id/feed - Feed pet
   * /api/pets/:id/play - Play with pet
Level Routes
   * Purpose: Manage level selection and completion
   * Endpoints:
   * /api/levels - List available levels
   * /api/levels/:id - Get quest levels
   * /api/levels/:id/start - Start a level
   * /api/levels/:id/complete - Complete a level
Item Routes
   * Purpose: Manage virtual items and shopping
   * Endpoints:
   * /api/items/inventory - View user's items
   * /api/items/:id/use - Use an item
2.4 Service Layer
User Service
   * Purpose: Manages user accounts and profiles
   * Functionality:
   * User registration and profile management
   * Inventory management
   * Currency tracking and transactions
   * Password reset functionality
Pet Service
   * Purpose: Handles pet creation and management
   * Functionality:
   * Pet creation
   * Pet status tracking and updates
   * Pet interactions (feeding, playing)
   * Equipment management
   * Level and experience tracking
Item Service
   * Purpose: Handles virtual items and inventory
   * Functionality:
   * Inventory management
   * Item usage effects
   * Equipment handling
Game Mechanics Service
   * Purpose: Implement game rules and calculations
   * Functionality:
   * XP and leveling algorithms
   * Stat decay over time
   * Implementation of item and ability effects
________________


2.5 Data Layer
MongoDB Atlas
   * Purpose: Primary data store
   * Data Stored:
   * User accounts and profiles
   * Pet data
   * Quest definitions and active quests
   * Item definitions and inventory
File Storage
   * Purpose: Store static assets
   * Data Stored:
   * Pet images
   * Item images
   * Quest images
   * User avatars
________________
      3. Data Models
3.1 System Overview Diagram
  

3.2 ER-Diagram
  
  
  

3.3 Data Flow Diagrams
      3.3.1 Pet Creation Flow
  

      3.3.2 Quest Selection Flow
  

3.4 Data Transformation Examples
Example 1 : Creating Pet
Input Data: name: Luna, species: dragon
Transforming step: 1. Add user ID: req.user.id -> “1234567890abcd1234”
                       2. Validate the Input data
                       3. Check if user already has a pet or not (each user only have one pet)
                       4. Default value injection for : level : 1; experience : 0; attributes : 0; 
createdAt: "2023-01-15T13:45:30.123Z"
                       5. Create Pet document
                       6. Update user document with pet reference
Example 2 : Starting a Quest
Input Data: POST to /api/quests/1234567890abcd1234/start 
Transforming step: 1. Find quest by ID: "1234567890abcd1234", 
Quest: "Forest Adventure" (Easy, 20 min duration, minLevel: 1)
                       2. Verify quest is active
                       3. Find the user's pet
                       4. Check if pet is already on a quest 
                       5. Verify pet meets quest requirements
                       6. Calculate the quest completion time with startTime, duration and  
completionTime
       7. Create ActiveQuest document
       8. Update pet's activeQuest reference and reduce energy
       9. Save pet document
Example 3 : Feeding a Pet
Input Data: "itemId": "8123456789abcdef01234567" 
Transforming step: 1. Find user's pet (no need for petId parameter now) 
        2. Find item by ID: "8123456789abcdef01234567"
Item is "Premium Food" with effects: { hunger: 40, happiness: 10 } 
        3. Verify user has the item in inventory 
        4. Calculate new pet stats: 
pet.attributes.hunger: 70 + 40 = 100 (capped at max 100) 
pet.attributes.happiness: 80 + 10 = 90 
pet.lastFed = currentTime 
        5. Remove item from inventory (decrease quantity by 1) 
        6. Save changes to both pet and user documents




________________


      4. Interface Design
4.1 Communication Architecture
        4.1.1 React-Phaser Bridge
        Being a web-based game, PetQuest is developed with two main frameworks: ReactJS and Phaser, providing smooth user experience as well as less complicated development process for the whole system. With this approach, the communication architecture could be simplified, as displayed in the following figure:
  
The communication bridge is well-defined between React components such as LoginPage.jsx and the Phaser game engine. Event Bus is a central event emitter which enables bidirectional communication.


       4.1.2 React Components to Phaser Scenes
// Emit events from React to Phaser
EventBus.emit('current-scene-ready', this);
// Access game instance from React using useRef()
phaserRef.current.game
phaserRef.current.scene   
      
       4.1.3 Phaser Scenes to React Components
// Notify React of scene changes
EventBus.emit('current-scene-ready', this);
// Access global context from Phaser
const globalContext = getGlobalContext();
________________


4.2 Data Flow Operations
       4.2.1 Scene Transitions
Input
	Output
	      * Scene Name - string
      * Optional data object
      * level - int
      * nextScene - string
	A new scene is initialized with provided input.
	

Example:
// in MainMenu.js
this.scene.start('LevelTransition', { 
    level: user.lastLevel,
    nextScene: user.lastLevel.scene
});


4.3 User Data Operations
       4.3.1 User Management with Exception Management      
  // Update user data functions
  const updateUsername = (name) => {
    setUserData(prev => ({ ...prev, username: name }));
  };


  // Select a pet and store it in the user data
  const selectPet = (petData) => {
    setUserData(prev => ({ ...prev, pet: petData }));
  };


// Update the user's level
  const updateLevel = (newLevel) => {
    setUserData(prev => ({ ...prev, level: newLevel }));
  };
 
________________


// Load user data from storage when app starts
  useEffect(() => {
    const loadUserData = () => {
      try {    
        // Get data from the server
        const storedUserData = fetch('https://petquest.com/api/auth/me', {
          method: 'GET',
          headers: { 
               'Content-Type': 'application/json',
               'token': user.token,
          }
        }).then(response => response.json())
        if (storedUserData) {
          setUserData(JSON.parse(storedUserData));
        }
      } catch (error) {
        console.error('Failed to load user data', error);
      }
    };
    loadUserData();
  }, []);




// Save user data to storage whenever it changes
  useEffect(() => {
    const saveUserData = () => {
      try {
        // Save data to the server
        fetch('https://petquest.com/api/auth/me', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'token': user.token,
          },
          body: JSON.stringify(userData)
        });
      } catch (error) {
        console.error('Failed to save user data', error);
      }
    };


    if (userData.username) {
      saveUserData();
    }
  }, [userData]);


By using try-catch blocks, it can manage exceptions and prevent the game from crashing if saving data fails.
                                    
      5. Component design
5.1. Interaction Class
5.1.1. Responsibilities
      * Establish the basis of the attributes of a pet and individual functions for data manipulations for all changeable attributes
      * Provide various methods to manipulate the stats of a player’s pet
      * Encourage regular interactions between the play and pet to play the game
      * Carry out value calculations and check when the player actions
      * Involve a chance-based system to increase the randomness of gameplay
5.1.2. Input/Output Specifications
      * Input:
      * Objects: food items, medicines -> validated when used
      * Events: games, training, cleaning, outdooring -> simulate pet raising experience
      * Output:
      * Basic stats: Increase and decrease of HP, SP, stamina, attack, defense, affection, level, exp
      * Specific stats: getting buff and debuff, stage advances every 10 levels (final stage reached at level 30)
      * Warnings: Change of basic stats when getting certain buffs and debuffs, unable to enter battle with too low affections or stamina
// PET CLASS
class Pet {
    constructor(name, hp, sp, stamina, attack, defense, affection, characteristic, buff, debuff, level, exp, stage) {
        // Individual predefined values are given to prevent empty attributes
        this.name = name || "Pet";                          // Player decide name
        this.hp = hp || MAX_VALUE;                          // Health point (Max: 100)  
        this.sp = sp || MAX_VALUE;                          // Stamina point (Max: 100)
        this.stamina = stamina || 20;                       // Stamina (Consumed when entering battle
        this.attack = attack || 10;                         // Use to calculate damage dealt
        this.defense = defense || 5;                        // Use to calculate damage taken
        this.affection = affection || ZERO_VALUE;           // Encourage interactions with pet
        this.characteristic = characteristic || "Calm";     // Specific characteristic for each pet
        this.buff = buff || "None";                         // Getting one buff at a time
        this.debuff = debuff || "None";                     // Getting one debuff at a time
        this.level = level || MINIMUM_STAT;                 // Record the current level of the pet
        this.exp = exp || ZERO_VALUE;                       // Level up consumes every 100 exp
        this.stage = stage || "Elementary";       // “Elementary”, “Intermediate”, “Advanced”, “Final”
    }




// CONSTANTS
// Global numeric values
const ZERO_VALUE = 0, MAX_VALUE = 100, MINIMUM_STAT = 1, EXP_LIMIT = 100;
const traits = { ... };        // Pet's characteristics
const condition = { ... };     // Buffs and Debuffs
let order = 0;                 // Order of attack
let critical = false;          // Critical hit
let immobilize = 0;            // Immobilize (>= 0: Normal, < 0: Number of turns skipped)
const food = { ... };          // Food items
const medicine = { ... };      // Medicines
const game = { ... };          // Games to choose
let play_game_CD = 0;          // Cooldown for playing game
const training = { ... };      // Training event
let training_CD = 0;           // Cooldown for training
const clean = { ... };         // Cleaning events
let cleanness = 0;             // Cleanliness of pet
const outdoor = { ... };       // Outdoor events
let outdoor_CD = 0;            // Cooldown for going out
let stat = { ... };            // variable storing the most updated pet stats


5.1.3. Pet data storage and retrieval
Recording the data of pet stats after every valid action for future use
export let stat = {    // Variables storing pet’s stats
    // Temporary (Max) values are given as a template of pet data
    hp: MAX_VALUE,
    sp: MAX_VALUE,
    stamina: MAX_VALUE,
    attack: 10,
    defense: 5,
    affection: 10,
    buff: "None",
    debuff: "None",
    level: MINIMUM_STAT,
    exp: ZERO_VALUE,
    stage: "Elementary"
};




// Combines with the above function to store pet data for later retrieval
record_pet_data() {    // Functions for getting and storing pet data
    stat.hp = this.hp;
    stat.sp = this.sp;
    stat.stamina = this.stamina;
    stat.attack = this.attack;
    stat.defense = this.defense;
    stat.affection = this.affection;
    stat.buff = this.buff;
    stat.debuff = this.debuff;
    stat.level = this.level;
    stat.exp = this.exp;
    stat.stage = this.stage;
}
Retrieving the current pet data
get_pat_data(index) {        // Simple function for getting the current pet data (Index based)
        switch (index) {     // It is easy to add more stats types in an index based system
            case 1:
                return this.hp;
            case 2:
                return this.sp;
            case 3:
                return this.stamina;
            case 4:
                return this.attack;
            case 5:
                return this.defense;
            case 6:
                return this.affection;
            case 7:
                return this.characteristic;
            case 8:
                return this.buff;
            case 9:
                return this.debuff;
            case 10:
                return this.level;
            case 11:
                return this.exp;
            case 12:
                return this.stage;
            default:
                return null;
        }
    }


5.1.4. Pet data manipulations
Basic template of increasing and decreasing stats in a similar style for other functions
increase_hp(number) {        // Increasing HP
    this.hp = Math.min(this.hp + number, stat.hp);            // Calculate the limit with new values
    if(this.hp === stat.hp) {                                 // Reaching 100 HP (Full)
        console.log("HP full!");
    }
    console.log("HP increased by %d.", number);               // Message notifying the player
}


decrease_hp(number) {        Decreasing HP                  
    if(this.hp - number > ZERO_VALUE) {                       // HP must be non-negative integer
        this.hp -= number;
    } else {
        this.hp = ZERO_VALUE;
        console.log(this.name + " is unable to fight now!");  // Cannot enter battle with 0 hp
    }
    console.log("HP decreased by %d.", number);               // Message notifying the player
}


5.1.5. Getting specific buffs and debuffs and corresponding actions
Each buff and debuff provides specific benefits or disadvantages to pet in battle
export const condition = {  // Buffs and Debuffs
    blessed: "BLESSED",     // Increasing pet’s HP by blessed_value every turn
    rampage: "RAMPAGE",     // Increase pet’s HP by rampage_value for damage taken
    agitated: "AGITATED",   // Increase pet’s attack by agitated_value every turn
    swift: "SWIFT",         // Pet must action before enemy when battle starts
    critical: "CRITICAL",   // Pet has a critical_value times of chance to deal 1.5 times damage
    poison: "POISON",       // Decreasing HP by poison_value every turn
    paralysis: "PARALYSIS", // Pet has a paralysis_value times of chance which it cannot deal damage
    sleep: "SLEEP",         // Pet must be behind of enemy action when battle starts
    frozen: "FROZEN",       // Pet has frozen_value turn skipped when battle starts
    exhausted: "EXHAUSTED", // Decrease pet’s attack and defense by exhausted_value every turn
    // Values used in each condition, can be easily changed for balance of the game
    blessed_value: 5,
    rampage_value: 2,
    agitated_value: 3,
    swift_value: 1,
    critical_value: 1.7,
    poison_value: 3,
    paralysis_value: 0.3,
    sleep_value: 0,
    frozen_value: 1,
    exhausted_value: 2
};


// Function for giving buff to pet (The function of giving debuff is very similar)
get_buff(effect) {
    if(this.buff !== "None") {   // Only one buff at a time
        console.log(this.name + " already has a buff!");
        return;
    }
    // Giving buff when the pet does not possess one currently
    this.buff = effect;
    switch (effect) {
        // Announcement is displayed to player when a buff is given
        case condition.blessed:    
            console.log(this.name + " is blessed!");
            break;
        case condition.rampage:    
            console.log(this.name + " is on rampage!");
            break;
        case condition.agitated:    
            console.log(this.name + " is agitated!");
            break;
        case condition.swift:      
            console.log(this.name + " is swift!");
            break;
        case condition.critical:    
            console.log(this.name + " is critical!");
            break;
        default:
            console.log("Buff not exist.");    // Error message for unknown input of buff              
            break;
    }
}


// Performing respective actions to pet when possessing certain buffs or debuffs
// Functions are used to change the pet’s data to reduce number of bugs and increase validity
    condition_check(buff, debuff) {
        if(buff !== "None") {
            switch(effect) {
                case condition.blessed:
                    this.increase_hp(condition.blessed_value);
                    break;
                case condition.rampage:
                    this.increase_hp(condition.rampage_value);
                    break;
                case condition.agitated:
                    this.increase_attack(condition.agitated_value);
                    break;
                case condition.swift:
                    order = swift_value;
                    break;
                case condition.critical:
                    if(Math.random() > condition.critical_value)
                        critical = true;
                    break;
                default:
                    break;
            }
        }
        if(debuff !== "None") {
            switch(effect) {
                case condition.poison:
                    this.decrease_hp(condition.poison_value);
                    break;
                case condition.paralysis:
                    if(Math.random() > condition.paralysis_value) {
                        immobilize = -1;
                    }
                    break;
                case condition.sleep:
                    order = sleep_value;
                    break;
                case condition.frozen:
                    order = (0 - frozen_value);
                    break;
                case condition.exhausted:
                    this.decrease_attack(condition.exhausted_value);
                    this.decrease_defense(condition.exhausted_value);
                    break;
                default:
                    break;
            }
        }
    }


5.1.6. Level up of pet
Providing a way to permanently increase the basic stats of pet until max level reached
increase_level() {     // Increasing level
    this.level += MINIMUM_STAT;
    console.log(this.name + " reaches level %d!", this.level);
    if(this.level % 10 === 0) {  // Evolve every 10 levels
        this.evolve();
    }
    this.update_stat();
}


update_stat() {        // Function updating the pet’s basic stats after level up
    this.increase_hp(2);
    this.increase_sp(2);
    this.increase_attack(1);
    this.increase_defense(1);
    console.log("Stats upgraded!");
}


increase_exp(number) {      
    if(this.stage === "Final") {    // “Final” stage is the last stage
        console.log("Max level!\nCannot gain anymore EXP.");
    } else if(this.exp + number >= EXP_LIMIT) { // Level up
        console.log("Gained %d EXP!\nLevel up!", number);
        this.exp = this.exp + number - EXP_LIMIT;
        this.increase_level();
    } else {  
        this.exp += number;
        console.log("Gained %d EXP!", number);
    }
}


evolve() {  // A pet’s stage must lie on these 4 stages                
    if (this.stage === "Elementary") {
        this.stage = "Intermediate";
        console.log(this.name + " evolved into " + this.stage + " stage!");
    } else if (this.stage === "Intermediate") {
        this.stage = "Advanced";
        console.log(this.name + " evolved into " + this.stage + " stage!");
    } else if (this.stage === "Advanced") {
        this.stage = "Final";
        console.log(this.name + " evolved into " + this.stage + " stage!");
    }
}


5.1.7. Feeding your pet
Feeding your pet with food items increases their stamina, which is consumed when entering battle. 
export const food = {        // List of food items available, can be expanded
    cookies: "COOKIES",
    candies: "CANDIES",
    fish: "FISH",
    meat: "MEAT",
    lollipop: "LOLLIPOP",
    cookies_value: 5,        // Corresponding amount of stamina each food can regenerate
    candies_value: 10,
    fish_value: 15,
    meat_value: 20,
    lollipop_value: 30
};


feed(item, number) {         // The food item and its quantity need to be specify 
    switch (item) {          
        case food.cookies:   // It is not unable to feed your pet for over 100 stamina (Game design)
            if ((this.stamina + number * food.cookies_value) <= MAX_VALUE) {
                console.log("Consumed %d %s.", number, food.cookies);
                this.increase_stamina(number * food.cookies_value);
            } else {         // Allow the player to immerse into actually feeding pets
                console.log(this.name + " cannot eat this much!\nPlease choose another item.");
            }
            break;
        case food.candies:
            if ((this.stamina + number * food.candies_value) <= MAX_VALUE) {
                console.log("Consumed %d %s.", number, food.candies);
                this.increase_stamina(number * food.candies_value);
            } else {
                console.log(this.name + " cannot eat this much!\nPlease choose another item.");
            }                
            break;
        case food.fish:
            if ((this.stamina + number * food.fish_value) <= MAX_VALUE) {
                console.log("Consumed %d %s.", number, food.fish);
                this.increase_stamina(number * food.fish_value);
            } else {
                console.log(this.name + " cannot eat this much!\nPlease choose another item.");
            }
            break;
        case food.meat:
            if ((this.stamina + number * food.meat_value) <= MAX_VALUE) {
                console.log("Consumed %d %s.", number, food.meat);
                this.increase_stamina(number * food.meat_value);
            } else {
                console.log(this.name + " cannot eat this much!\nPlease choose another item.");
            }                
            break;
        case food.lollipop:
            if ((this.stamina + number * food.lollipop_value) <= MAX_VALUE) {
                console.log("Consumed %d %s.", number, food.lollipop);
                this.increase_stamina(number * food.lollipop_value);
            } else {
                console.log(this.name + " cannot eat this much!\nPlease choose another item.");
            }
            break;
        default:             // Error message given when a non-food item is specified
            console.log("This is not food!\nPlease choose another item.");
            break;
    }
}


5.1.8. Treating your pet
export const medicine = {       // List of usable medicines
    bandage: "BANDAGE",         // Healing a certain amount of HP of pet
    potion: "POTION",
    mega_potion: "MEGA POTION",
    max_potion: "MAX POTION",
    revive: "REVIVE",           // Has a chance to be able to re-enter battle
    holy_water: "HOLY WATER",   // Remove debuff when consumed
    bandage_value: 5,
    potion_value: 10,
    mega_potion_value: 15,
    max_potion_value: 20
};


treatment(item) {      
    switch (item) {
        case medicine.bandage:
            console.log("Treated with bandage.");
            this.increase_hp(medicine.bandage_value);
            break;
        case medicine.potion:
            console.log("Treated with potion.");
            this.increase_hp(medicine.potion_value);
            break;
        case medicine.mega_potion:
            console.log("Treated with mega potion.");
            this.increase_hp(medicine.mega_potion_value);
            break;
        case medicine.max_potion:
            console.log("Treated with max potion.");
            this.increase_hp(medicine.max_potion_value);
            break;
        case medicine.revive:        // A revived pet will have half of its max HP back
            console.log("Revived!");
            this。hp = Math.round(stat.hp / 2);            
            break;
        case medicine.holy_water:    // Consuming holy water can remove any debuff the pet has
            console.log("Treated with holy water.");
            this.debuff = "None";
            break;
        default:                     // Only medicine items can be used in this function
            console.log("This is not medicine!\nPlease choose another item.");
            break;
    }
}


5.1.9. Playing games with your pet
The player can play some mini-games with pet to increase their affection.
export const game = {        // List of playable games
    laser_game: "LASER GAME",
    hide_and_seek: "HIDE AND SEEK",
    fetching: "FETCHING",    
    tug_of_war: "TUG OF WAR",
    playing_toys: "PLAYING_TOYS",
    laser_game_value: 10,
    hide_and_seek_value: 10,
    fetching_value: 20,
    tug_of_war_value: 20,
    playing_toys_value: 30
};


mini_game(event) {           // Playing the given games
    if(play_game_CD < 3) {   // In between each battle, at most 3 games can be played
        play_game_CD++;
        switch (event) {     // Only way to increase affection, encourages player-pet interactions
            case game.laser_game:
                this.increase_affection(game.laser_game_value);
                break;
            case game.hide_and_seek:
                this.increase_affection(game.hide_and_seek_value);
                break;
            case game.fetching:
                this.increase_affection(game.fetching_value);
                break;
            case game.tug_of_war:
                this.increase_affection(game.tug_of_war_value);
                break;
            case game.playing_toys:
                this.increase_affection(game.playing_toys_value);
                break;
            default:
                console.log("Game not found!");
                break;
        }
    } else {        // Message to player when the pet has already played 3 games in this turn
        console.log(this.name + " is too tired to play games!\nPlease wait for a while.");
    }
}


5.1.10. Training your pet
Performing training to your pet as a way to increase pet’s exp, it is recommended if the pet is unable to clear the current battle.
export const training = {        // List of trainings
    running: "RUNNING",    
    swimming: "SWIMMING",
    jumping: "JUMPING",
    climbing: "CLIMBING",
    weight_lifting: "WEIGHT LIFTING",
    running_value: 10,
    swimming_value: 10,
    jumping_value: 20,
    climbing_value: 20,
    weight_lifting_value: 30
};


training(event) {    
    if(training_CD < 3) {        // A pet cannot train for more than 3 times between each battle 
        training_CD++;        
        switch (event) {
            case training.running:
                this.increase_exp(training.running_value);
                break;
            case training.swimming:
                this.increase_exp(training.swimming_value);
                break;
            case training.jumping:
                this.increase_exp(training.jumping_value);
                break;
            case training.climbing:
                this.increase_exp(training.climbing_value);
                break;
            case training.weight_lifting:
                this.increase_exp(training.weight_lifting_value);
                break;
            default:
                console.log("Training not found!");
                break;
        }
    } else {
        console.log(this.name + " is too tired to train!\nPlease wait for a while.");
    }
}


5.1.11. Cleaning your pet
export const clean = {       // List of cleaning activities
    brush: "BRUSH",
    clean_environment: "CLEAN ENVIRONMENT",    
    bath: "BATH",
    brush_value: 5,
    clean_environment_value: 5,
    clean_value: 10
};
export let cleanness = 0;    // Cleanliness of pet and environment


cleaning(event) {            // Function responsible for cleaning
    if(cleanness < 5) {      // Check for cleanness when player wants to clean
        console.log(this.name + " is dirty!\nPlease clean her.");
        this.decrease_affection(10);    // Decrease affection when cleanness is too low
    }
    switch (event) {        
        case clean.brush:
            cleanness += clean.brush_value;
            break;
        case clean.clean_environment:
            cleanness += clean.clean_environment_value;
            break;
        case clean.bath:
            cleanness += clean.bath_value;
            break;
        default:             // Inappropriate event specified
            console.log("This is not cleaning!");
            break;
    }
}


5.1.12. Going outdoor
export const outdoor = {    // List of all outdoor activities
    restaurant: "RESTAURANT",
    shopping: "SHOPPING",    
    park: "PARK",
    beach: "BEACH",
    travelling: "TRAVELLING",    
    restaurant_value: 0.1,  // Values representing probability of accident occurring
    shopping_value: 0.1,
    park_value: 0.2,
    beach_value: 0.2,
    travelling_value: 0.3
};


going_out(event) {
    if(outdoor_CD < 1) {    // Only one outdoor activity in between battle
        outdoor_CD++;
        switch (event) {    // Each activity corresponds to a pair of buff and debuff
            case outdoor.restaurant:
                console.log("Went to restaurant.");
                // Mixed with probability to increase randomness
                if(Math.random() > outdoor.restaurant_value) {  
                    console.log("The food is delicious!");
                    this.get_buff(condition.blessed);
                } else {    // Buff and debuff in a pair are of the same genre
                    console.log("Oh no!\nThe food is bad!");
                    this.get_debuff(condition.poison);
                }
                break;
            case outdoor.shopping:
                console.log("Went shopping.");
                if(Math.random() > outdoor.shopping_value) {
                    console.log("Bought a lot of things!");
                    this.get_buff(condition.rampage);
                } else {
                    console.log("Oh no!\nGot scammed!");
                    this.get_debuff(condition.paralysis);
                }
                break;
            case outdoor.park:
                console.log("Went to park.");
                if(Math.random() > outdoor.park_value) {
                    console.log("Spent a great time!");
                    this.get_buff(condition.agitated);
                } else {
                    console.log("Oh no!\nGot tired!");
                    this.get_debuff(condition.sleep);
                }
                break;
            case outdoor.beach:
                console.log("Went to beach.");
                if(Math.random() > outdoor.beach_value) {
                    console.log("Had a lot of fun!");
                    this.get_buff(condition.swift);
                } else {
                    console.log("Oh no!\nGot cold!");
                    this.get_debuff(condition.frozen);
                }
                break;
            case outdoor.travelling:
                console.log("Went travelling.");
                if(Math.random() > outdoor.travelling_value) {
                    console.log("Had a great adventure!");
                    this.get_buff(condition.critical);
                } else {
                    console.log("Oh no!\nGot jet lag!");
                    this.get_debuff(condition.exhausted);
                }
                break;
            default:
                console.log("This is not going out!");
                break;
        }
    }
}


5.1.13. Specialised traits for pet and corresponding abilities
export const traits = {     // Pet's specific characteristics
    calm: "CALM",           // Increase Defense by 1 every 2 turn, have 30% chance to not consume SP
    rage: "RAGE",           // Increase Attack by 1 every 2 turn, have 30% chance to deal 1.5 times                  damage
    hopeful: "HOPEFUL",     // Regenerate 3 HP every 2 turn, have 30% chance to heal extra 1 HP every                 turn
    timid: "TIMID",         // Regenerate 5 SP every 2 turn, have 30% chance to dodge enemy's attack
    curious: "CURIOUS",     // Randomly increase 1 HP/SP/Attack/Defense every 2 turn, have 30% chance                 to gain shield when entering battle
    active: "ACTIVE"        // Must move before enemy, have 30% chance to attack twice in one turn
};


let hp_free = 0, sp_free = 0, gain_shield = 0, double_hit = 0;


talents(characteristic, turn_number) {      // Performing individual actions for corresponding traits
    switch(characteristic) {
        case characteristic.calm:
            if(turn_number % 2 === 0) {
                this.increase_defense(1);   // Increasing defense every 2 turns
            }
            if(Math.random() <= 0.3) {
                sp_free = 1;                // Sending back to battle system to ignore SP consumption
            }
            break;
        case characteristic.rage:
            if(turn_number % 2 === 0) {
                this.increase_attack(1);    // Increasing attack every 2 turns
            }
            if(Math.random() <= 0.3) {
                critical = 1;               // Signal for critical hit
            }
            break;
        case characteristic.hopeful:
            if(turn_number % 2 === 0) {
                this.increase_hp(3);        // Increasing HP every 2 turns
            }
            if(Math.random() <= 0.3) {
                this.increase_hp(1);        // Extra HP regeneration
            }
            break;
        case characteristic.timid:
            if(turn_number % 2 === 0) {
                this.increase_sp(5);        // Increasing SP every 2 turns
            }
            if(Math.random() <= 0.3) {
                hp_free = 1;                // Signal for ignoring damage
            }
            break;
        case characteristic.curious:
            if(turn_number % 2 === 0) {
                // Randomly choose one stat to increase
                let random = Math.floor(Math.random() * 4);    // 4 stats to randomly choose from  
                switch(random) {
                    case 0:
                        this.increase_hp(1);
                        break;
                    case 1:
                        this.increase_sp(1);
                        break;
                    case 2:
                        this.increase_attack(1);
                        break;
                    case 3:
                        this.increase_defense(1);
                        break;
                    default:
                        break;
                }
            }
            gain_shield = 1;                // Getting a shield
            break;
        case characteristic.active:
            if(turn_number === 1) {         // Only guaranteed for the first turn
                order = 1;
            }
            if(Math.random() <= 0.3) {  
                double_hit = 1;             // Signal for able to attack twice
            }
            break;
        default:
            console.log("This is not a pet's trait!");
            break;
    }
}


5.2. BattleSystem Class
Responsibilities
      * Manage the flow of a turn-based battle between a player pet and an enemy
      * Track battle state including current turn, health points, and battle conditions
      * Execute combat actions (attack, defend, use ability, feed pet)
      * Handle AI decision-making for enemy turns
      * Generate battle rewards upon completion
Input/Output Specifications
      * Input: Player pet object, enemy object, battleground string
      * Output: Battle result (win/loss), battle log, enemy drops
5.2.1. constructor
Initializes player pet, enemy, battleground, and battle state variables
// Main battle class to handle the battle system
class BattleSystem {
    constructor(playerPet, enemy, battleground) {
      this.playerPet = playerPet; 
      this.enemy = enemy;
      this.battleground = battleground;
      this.currentTurn = null; // Will store 'player' or 'enemy'
      this.turnCount = 0;
      this.battleLog = [];
      this.isPlayerDefending = false;
      this.isEnemyDefending = false;
      this.itemUsedThisTurn = false;
    }
5.2.2. startBattle 
Initializes the battle, logs combatant information, and determines first turn via coin toss
startBattle() {
      this.battleLog.push("Battle started!");
      this.battleLog.push(`${this.playerPet.name} vs ${this.enemy.name}`);
      this.battleLog.push(`Battleground: ${this.battleground}`);
     
      // Throw coin to decide who goes first
      this.throwCoin();
     
      return this.battleLog;
    }


5.2.3. nextTurn
Advances to the next turn, resets defensive stances, and checks if battle has ended
nextTurn() {
      // Check if battle has ended
      if (this.checkBattleEnd()) {
        return false;
      }


      // Reset defending status when turn changes
      if (this.currentTurn === 'player') {
        this.currentTurn = 'enemy';
        this.isPlayerDefending = false;
        this.itemUsedThisTurn = false; // Reset item usage for player's next turn
      } 
      else {
        this.currentTurn = 'player';
        this.isEnemyDefending = false;
        this.turnCount++; // Increment turn count after enemy's turn
      }
     
      this.battleLog.push(`Turn ${this.turnCount + 1}: ${this.currentTurn === 'player' ?
                          this.playerPet.name : this.enemy.name}'s turn`);
     
      return true;
    }


5.2.4. checkBattleEnd
Verifies if either player pet or enemy has been defeated (HP ≤ 0)
checkBattleEnd() {
      if (this.playerPet.hp <= 0) {
        this.battleLog.push(`${this.playerPet.name} has been defeated. You lost the battle.`);
        return true;
      } 
      else if (this.enemy.hp <= 0) {
        this.battleLog.push(`${this.enemy.name} has been defeated. You won the battle!`);
        // Generate drops from enemy
        const drops = this.generateEnemyDrops();
        this.battleLog.push(`${this.enemy.name} dropped: ${drops.join(', ')}`);
        return true;
      }
      return false;
    }


5.2.5. attack
Executes a basic attack, calculating damage based on attacker's stats and defender's stance
attack(attacker, defender, isDefending) {
      // Calculate base damage
      const baseDamage = attacker.attack;
     
      // Apply random variation (90% to 110% of base damage)
      const damageVariation = Math.random() * 0.2 + 0.9;
      let finalDamage = Math.floor(baseDamage * damageVariation);
     
      // If defender is defending, reduce damage by 50%
      if (isDefending) {
        finalDamage = Math.floor(finalDamage * 0.5);
        this.battleLog.push(`${defender.name} is defending and takes reduced damage!`);
      }
     
      // Apply damage to defender
      defender.hp -= finalDamage;
      if (defender.hp < 0) defender.hp = 0;
     
      this.battleLog.push(`${attacker.name} attacks ${defender.name} for ${finalDamage} damage!`);
      this.battleLog.push(`${defender.name} has ${defender.hp} HP remaining.`);
     
      return finalDamage;
    }


5.2.6. useAbility
Activates a special ability from attacker's ability list with appropriate effects
useAbility(attacker, defender, abilityIndex, isDefending) {
      // Check if ability exists
      if (abilityIndex >= attacker.abilities.length) {
        this.battleLog.push("That ability doesn't exist!");
        return false;
      }
     
      const ability = attacker.abilities[abilityIndex];
     
      // Check if ability is on cooldown
      if (ability.currentCooldown > 0) {
        this.battleLog.push(`${ability.name} is on cooldown for ${ability.currentCooldown} more turns!`);
        return false;
      }
     
      // Execute ability
      let damage = ability.damage;
     
      // If it's a damage ability and defender is defending, reduce damage
      if (damage > 0 && isDefending) {
        damage = Math.floor(damage * 0.5);
        this.battleLog.push(`${defender.name} is defending and takes reduced damage!`);
      }
     
      // Apply ability effects
      // These are just basic effect types as sample, there will be different unique ability for each pet
      switch (ability.type) {
        case 'damage':
          defender.hp -= damage;
          if (defender.hp < 0) defender.hp = 0;
          this.battleLog.push(`${attacker.name} uses ${ability.name} on ${defender.name} for ${damage} damage!`);
          break;
         
        case 'heal':
          attacker.hp += ability.healing;
          if (attacker.hp > attacker.maxhp) attacker.hp = attacker.hp;
          this.battleLog.push(`${attacker.name} uses ${ability.name} and heals for ${ability.healing} HP!`);
          break;
         
        case 'buff':
          attacker.attack += ability.attackBuff || 0;
          attacker.defense += ability.defenseBuff || 0;
          this.battleLog.push(`${attacker.name} uses ${ability.name} and gains ${ability.attackBuff || 0} attack and ${ability.defenseBuff || 0} defense!`);
          break;
         
        case 'debuff':
          defender.attack -= ability.attackDebuff || 0;
          defender.defense -= ability.defenseDebuff || 0;
          if (defender.attack < 0) defender.attack = 0;
          if (defender.defense < 0) defender.defense = 0;
          this.battleLog.push(`${attacker.name} uses ${ability.name} on ${defender.name}, reducing attack by ${ability.attackDebuff || 0} and defense by ${ability.defenseDebuff || 0}!`);
          break;
      }
     
      // Set cooldown
      ability.currentCooldown = ability.cooldown;


      // Update status
      this.battleLog.push(`${defender.name} has ${defender.hp} HP remaining.`);
     
      return true;
    }


5.2.6. defend
Sets defensive stance for the current combatant, reducing damage from next attack
defend(character) {
      if (this.currentTurn === 'player') {
        this.isPlayerDefending = true;
        this.battleLog.push(`${this.playerPet.name} takes a defensive stance!`);
      } else {
        this.isEnemyDefending = true;
        this.battleLog.push(`${this.enemy.name} takes a defensive stance!`);
      }
     
      return true;
    }


5.2.6. useitem
Applies item effects to player pet (heal, buff), limited to once per turn
useitem(item) {
      // Check if item has already been used this turn
      if (this.itemUsedThisTurn) {
        this.battleLog.push("You've already used item this turn!");
        return false;
      }
     
      // Apply item effects
      switch (item.type) {
        case 'heal':
          this.playerPet.hp += item.value;
          if (this.playerPet.hp > this.playerPet.maxhp) this.playerPet.hp = this.playerPet.maxhp;
          this.battleLog.push(`You used ${item.name} to ${this.playerPet.name} and restored ${item.value} HP!`);
          break;
         
        case 'attackBuff':
          this.playerPet.attack += item.value;
          this.battleLog.push(`You used ${item.name} to ${this.playerPet.name} and increased attack by ${item.value}!`);
          break;
         
        case 'defenseBuff':
          this.playerPet.defense += item.value;
          this.battleLog.push(`You used ${item.name} to ${this.playerPet.name} and increased defense by ${item.value}!`);
          break;
      }
     
      this.itemUsedThisTurn = true;
      return true;
    }
5.2.7. enemyTurn
Handles AI decision-making for enemy actions based on current battle state
// Handles AI decision-making for enemy actions
    enemyTurn() {
      // Simple AI logic for enemy turn
      const actions = ['attack', 'ability', 'defend'];
      let chosenAction;
     
      // Low HP behaviour - prioritize healing or defending
      if (this.enemy.hp < this.enemy.maxhp * 0.3) {
        // Check if enemy has healing abilities
        const healingAbilities = this.enemy.abilities.filter(
          ability => ability.type === 'heal' && ability.currentCooldown === 0
        );
       
        if (healingAbilities.length > 0) {
          // Use a healing ability
          const randomHealAbility = Math.floor(Math.random() * healingAbilities.length);
          const abilityIndex = this.enemy.abilities.indexOf(healingAbilities[randomHealAbility]);
          this.useAbility(this.enemy, this.playerPet, abilityIndex, this.isPlayerDefending);
          return;
        } else if (Math.random() < 0.7) {
          // 70% chance to defend when low on health
          this.defend(this.enemy);
          return;
        }
      }
     
      // Normal behaviour randomly choose an action
      // AI enemy behaviour will change which depends on the 
      chosenAction = actions[Math.floor(Math.random() * actions.length)];
     
      switch (chosenAction) {
        case 'attack':
          this.attack(this.enemy, this.playerPet, this.isPlayerDefending);
          break;
         
        case 'ability':
          // Filter available abilities (not on cooldown)
          const availableAbilities = this.enemy.abilities.filter(
            ability => ability.currentCooldown === 0
          );
         
          if (availableAbilities.length > 0) {
            // Use a random available ability
            const randomAbility = Math.floor(Math.random() * availableAbilities.length);
            const abilityIndex = this.enemy.abilities.indexOf(availableAbilities[randomAbility]);
            this.useAbility(this.enemy, this.playerPet, abilityIndex, this.isPlayerDefending);
          } else {
            // No abilities available, fallback to attack
            this.attack(this.enemy, this.playerPet, this.isPlayerDefending);
          }
          break;
         
        case 'defend':
          this.defend(this.enemy);
          break;
      }
    }
5.2.8. generateEnemyDrops
Creates random rewards when an enemy is defeated based on their drop tables
generateEnemyDrops() {
      const drops = [];
     
      // Calculate number of drops (1-3)
      const dropCount = Math.floor(Math.random() * 3) + 1;
     
      for (let i = 0; i < dropCount; i++) {
        // Check if enemy has specific drops
        if (this.enemy.possibleDrops && this.enemy.possibleDrops.length > 0) {
          // Calculate drop chance for each item
          this.enemy.possibleDrops.forEach(drop => {
            if (Math.random() < drop.chance) {
              drops.push(drop.item);
            }
          });
        }
       
        // If no specific drops or nothing dropped, generate generic drop
        if (drops.length === 0) {
          const genericDrops = ['Health Potion', 'Attack Boost', 'Defense Boost', 'Gold Coin'];
          drops.push(genericDrops[Math.floor(Math.random() * genericDrops.length)]);
        }
      }
     
      return drops;
    }
  }


5.3. Enemy Generator
Responsibilities
      * Create randomized enemies with appropriate stats and abilities
      * Scale enemies based on difficulty level
      * Generate enemies of specific types with their characteristic strengths and weaknesses
      * Create appropriate abilities for each enemy type
      * Create possible item drops for each enemy
Input/Output Specifications
      * Input: Difficulty level (integer), Optional enemy type override (string)
      * Output: Enemy object with all required properties
function generateEnemy(difficulty = 1, typeOverride = null) {
    // Enemy types with their base characteristics
    const enemyTypes = [
      {
        type: 'Strength',
        hpMod: 1.5,      // More HP
        attackMod: 1.3,  // More attack
        defenseMod: 1.0,
        abilityCount: 1, // Fewer abilities
        description: "A powerful enemy focused on high HP and attack damage"
      },
      {
        type: 'Speed',
        hpMod: 0.8,
        attackMod: 1.1,
        defenseMod: 0.7,
        abilityCount: 3, // More abilities
        description: "A fast enemy with multiple abilities but lower HP"
      },
      {
        type: 'Tank',
        hpMod: 2.0,      // Much more HP
        attackMod: 0.7,  // Less attack
        defenseMod: 1.5, // More defense
        abilityCount: 2,
        description: "A defensive enemy with high HP and defense"
      },
      {
        type: 'Balanced',
        hpMod: 1.0,
        attackMod: 1.0,
        defenseMod: 1.0,
        abilityCount: 2,
        description: "A balanced enemy with no particular strengths or weaknesses"
      },
      {
        type: 'Magical',
        hpMod: 0.9,
        attackMod: 0.8,
        defenseMod: 0.8,
        abilityCount: 4, // Most abilities
        description: "A magical enemy with many powerful abilities but lower stats"
      }
    ];
   
    // List of possible enemy names
    const enemyNames = [
      "Fierce Wolfling", "Thunder Lizard", "Shadow Bat", "Rock Golem",
      "Toxic Slime", "Forest Spirit", "Fire Salamander", "Frost Wolf",
      "Thunder Hawk", "Midnight Panther", "Mystic Owl", "Desert Scorpion",
      "Cave Troll", "Swamp Lurker", "Mountain Lion", "Crystal Elemental"
    ];
   
    // Choose enemy type (random or override)
    const enemyType = typeOverride ||
                      enemyTypes[Math.floor(Math.random() * enemyTypes.length)].type;
   
    // Find the type object
    const typeObj = enemyTypes.find(t => t.type === enemyType);
   
    // Generate base stats (scaled by difficulty)
    const baseHp = 50 + (difficulty * 20);
    const baseAttack = 10 + (difficulty * 5);
    const baseDefense = 5 + (difficulty * 3);
   
    // Apply type modifiers
    const maxHp = Math.floor(baseHp * typeObj.hpMod);
    const attack = Math.floor(baseAttack * typeObj.attackMod);
    const defense = Math.floor(baseDefense * typeObj.defenseMod);
   
    // Choose a random name
    const name = enemyNames[Math.floor(Math.random() * enemyNames.length)];
   
    // Generate abilities
    const abilities = generateEnemyAbilities(typeObj.abilityCount, enemyType, difficulty);
   
    // Generate possible drops
    const possibleDrops = generatePossibleDrops(enemyType, difficulty);
   
    // Create the enemy object
    const enemy = {
      name: name,
      type: enemyType,
      level: difficulty,
      maxHp: maxHp,
      hp: maxHp,
      attack: attack,
      defense: defense,
      abilities: abilities,
      possibleDrops: possibleDrops,
      description: typeObj.description
    };
   
    return enemy;
  }


5.3.1. generateEnemyAbilities
Creates appropriate abilities for an enemy based on their type and difficulty
function generateEnemyAbilities(count, type, difficulty) {
    // List of possible abilities by type
    const abilityTemplates = {
      'Strength': [
        { name: "Power Strike", type: "damage", damage: 20, cooldown: 3 },
        { name: "Crushing Blow", type: "damage", damage: 30, cooldown: 5 },
        { name: "Intimidate", type: "debuff", attackDebuff: 5, cooldown: 4 }
      ],
      'Speed': [
        { name: "Quick Slash", type: "damage", damage: 15, cooldown: 2 },
        { name: "Double Strike", type: "damage", damage: 10, cooldown: 1 },
        { name: "Evade", type: "buff", defenseBuff: 8, cooldown: 3 },
        { name: "Precision", type: "buff", attackBuff: 7, cooldown: 3 }
      ],
      'Tank': [
        { name: "Shield Bash", type: "damage", damage: 10, cooldown: 2 },
        { name: "Fortify", type: "buff", defenseBuff: 10, cooldown: 3 },
        { name: "Recover", type: "heal", healing: 20, cooldown: 4 }
      ],
      'Balanced': [
        { name: "Balanced Strike", type: "damage", damage: 15, cooldown: 2 },
        { name: "Focus", type: "buff", attackBuff: 5, defenseBuff: 5, cooldown: 3 },
        { name: "Minor Heal", type: "heal", healing: 15, cooldown: 3 }
      ],
      'Magical': [
        { name: "Fireball", type: "damage", damage: 25, cooldown: 3 },
        { name: "Ice Shard", type: "damage", damage: 15, cooldown: 2 },
        { name: "Arcane Blast", type: "damage", damage: 35, cooldown: 5 },
        { name: "Healing Light", type: "heal", healing: 20, cooldown: 4 },
        { name: "Mana Shield", type: "buff", defenseBuff: 10, cooldown: 3 },
        { name: "Curse", type: "debuff", attackDebuff: 7, defenseDebuff: 7, cooldown: 4 }
      ]
    };
   
    // Get ability templates for the enemy type
    const typeAbilities = abilityTemplates[type] || abilityTemplates['Balanced'];
   
    // Choose random abilities
    const selectedAbilities = [];
    const availableAbilities = [...typeAbilities]; // Create a copy to work with
   
    for (let i = 0; i < count && availableAbilities.length > 0; i++) {
      // Choose a random ability from the available ones
      const randomIndex = Math.floor(Math.random() * availableAbilities.length);
      const ability = { ...availableAbilities[randomIndex] }; // Clone the ability
     
      // Remove the chosen ability to avoid duplicates
      availableAbilities.splice(randomIndex, 1);
     
      // Scale ability based on difficulty
      if (ability.damage) ability.damage = Math.floor(ability.damage * (1 + (difficulty - 1) * 0.2));
      if (ability.healing) ability.healing = Math.floor(ability.healing * (1 + (difficulty - 1) * 0.2));
      if (ability.attackBuff) ability.attackBuff = Math.floor(ability.attackBuff * (1 + (difficulty - 1) * 0.2));
      if (ability.defenseBuff) ability.defenseBuff = Math.floor(ability.defenseBuff * (1 + (difficulty - 1) * 0.2));
      if (ability.attackDebuff) ability.attackDebuff = Math.floor(ability.attackDebuff * (1 + (difficulty - 1) * 0.2));
      if (ability.defenseDebuff) ability.defenseDebuff = Math.floor(ability.defenseDebuff * (1 + (difficulty - 1) * 0.2));
     
      // Add initial cooldown state
      ability.currentCooldown = 0;
     
      // Add to selected abilities
      selectedAbilities.push(ability);
    }
   
    return selectedAbilities;
  }


5.3.2. generatePossibleDrops
Defines potential item drops for an enemy based on their type and difficulty
function generatePossibleDrops(type, difficulty) {
    const drops = [];
   
    // Common drops for all enemy types
    drops.push({ item: "Health Potion", chance: 0.5 });
    drops.push({ item: "Gold Coins", chance: 0.8 });
   
    // Type-specific drops
    switch (type) {
      case 'Strength':
        drops.push({ item: "Strength Essence", chance: 0.3 });
        drops.push({ item: "Power Crystal", chance: 0.2 });
        break;
      case 'Speed':
        drops.push({ item: "Agility Essence", chance: 0.3 });
        drops.push({ item: "Speed Boots", chance: 0.2 });
        break;
      case 'Tank':
        drops.push({ item: "Defense Essence", chance: 0.3 });
        drops.push({ item: "Shield Fragment", chance: 0.2 });
        break;
      case 'Balanced':
        drops.push({ item: "Balance Essence", chance: 0.3 });
        drops.push({ item: "Mixed Crystal", chance: 0.2 });
        break;
      case 'Magical':
        drops.push({ item: "Magic Essence", chance: 0.3 });
        drops.push({ item: "Spell Scroll", chance: 0.2 });
        break;
    }
   
    // Rare drops based on difficulty
    if (difficulty >= 3) {
      drops.push({ item: "Rare Equipment", chance: 0.1 });
    }
   
    if (difficulty >= 5) {
      drops.push({ item: "Epic Equipment", chance: 0.05 });
    }
   
    return drops;
  }


5.4. Level Generator
Responsibilities
      * Create complete game levels with appropriate difficulty
      * Generate randomized environments (backgrounds)
      * Create appropriate enemy encounters for each level
      * Generate potential rewards and rewards
      * Create descriptive text for each level
Input/Output Specifications
      * Input: Difficulty level (integer)
      * Output: Complete level object with background, enemies, rewards and description
function generateLevel(difficulty = 1) {
    // Define possible backgrounds for battlefields
    const backgrounds = [
      "Forest Clearing",
      "Mountain Pass",
      "Desert Dunes",
      "Volcanic Cave",
      "Frozen Tundra",
      "Mystic Grove",
      "Ancient Ruins",
      "Coastal Reef",
      "Deep Dungeon",
      "Enchanted Castle"
    ];
   
    // Choose a random background
    const background = backgrounds[Math.floor(Math.random() * backgrounds.length)];
   
    // Determine number of enemies for this level (1-3 based on difficulty)
    const enemyCount = Math.min(3, Math.floor(Math.random() * 2) + difficulty);
   
    // Generate enemies
    const enemies = [];
    for (let i = 0; i < enemyCount; i++) {
      // Randomize enemy difficulty within a range
      const enemyDifficulty = Math.max(1, difficulty + Math.floor(Math.random() * 3) - 1);
      enemies.push(generateEnemy(enemyDifficulty));
    }
   
    // Generate possible rewards
    const rewards = generateLevelRewards(difficulty);
   
    // Create the level object
    const level = {
      name: `Level ${difficulty}: ${background}`,
      difficulty: difficulty,
      background: background,
      enemies: enemies,
      rewards: rewards,
      description: generateLevelDescription(background, enemies, difficulty)
    };
   
    return level;
  }




5.3.1. generateLevelRewards
Creates appropriate rewards/rewards for a level based on difficulty
function generateLevelRewards(difficulty) {
    const rewards = [];
   
    // Reward count based on difficulty (1-3)
    const rewardCount = Math.min(3, Math.ceil(difficulty / 2));
   
    // Common rewards
    const commonRewards = [
      "Health Potion",
      "Attack Boost",
      "Defense Boost",
      "Gold Coins",
      "Pet Treat"
    ];
   
    // Uncommon rewards (difficulty >= 3)
    const uncommonRewards = [
      "Ability Scroll",
      "Stat Enhancement",
      "Rare Pet Food",
      "Crafting Material"
    ];
   
    // Rare rewards (difficulty >= 5)
    const rareRewards = [
      "Legendary Equipment",
      "Pet Evolution Stone",
      "Powerful Ability",
      "Stat Multiplier"
    ];
   
    for (let i = 0; i < rewardCount; i++) {
      // Determine reward rareness
      let reward;
      const rareness = Math.random();
     
      if (difficulty >= 5 && rareness > 0.7) {
        // 30% chance for rare reward in high difficulty
        reward = rareRewards[Math.floor(Math.random() * rareRewards.length)];
      } else if (difficulty >= 3 && rareness > 0.4) {
        // 30% chance for uncommon reward in medium difficulty
        reward = uncommonRewards[Math.floor(Math.random() * uncommonRewards.length)];
      } else {
        // Common reward
        reward = commonRewards[Math.floor(Math.random() * commonRewards.length)];
      }
     
      rewards.push(reward);
    }
   
    return rewards;
  }










      6. User Interface Design
6.1. Site Map
  6.2. User Interface Design
6.2.1. Login Interface
  

Purpose: Entry point for all players to log in or register.
 Components:
      * Title: Displayed at the top in pixel art style (e.g., game name with a pet-themed graphic).
      * Username Field: Text input box for username.
      * Password Field: Text input box for password (masked).
      * Login Button: Button below fields to login.
      * Register Button: Button or link below Login for new users.
      * Background: Pixel art scene (e.g., a forest or pet arena).
 Transitions:
      * Login successful (existing user)  then transit to Home Page (if pet already chosen) or Pet Selection Interface (if first-time setup incomplete).
      * Register clicked → Prompts user to create account, then transit to Pet Selection Interface.
6.2.2. Pet Selection Interface
  

Purpose: Allows first-time players to choose their starting pet.
 Components:
      * Header: Text like “Choose Your Companion!” in pixel font.
      * Pet Options: 3-5 pet sprites (e.g., dog, cat, dragon) displayed in a card.
      * Each pet has a pixel art idle animation.
      * Pet Status: Show the status of pet (e.g., "Name, HP, High Attack, Low Defense")
      * Confirm Button: Finalizes pet selection (appears after selecting a pet).
      * Background: Pixel art scene (e.g., a forest or pet arena).
 Transitions:
      * Confirm clicking then transit to Home Page with the chosen pet.
6.2.3. Home Page
  

Purpose: Central hub for returning players to interact with their pet and access game features.
 Components:
      * Player Status: Panel on top, showing the player status (e.g. Username, Time played) 
      * Pet Display: Center of the screen, large animated sprite of the player’s pet.
      * Interaction: Clicking the pet triggers a short animation (e.g., jump, wag tail, sparkle effect).
      * Pet Status: Show the status of pet (e.g. HP, Level, Energy) in pixel text.
      * Button Bar (Bottom of Screen, buttons label in letters):
      * Feed Button: Regenerate stamina.
      * Play Button: Increase affection.
      * Train Button: Gain EXP.
      * Medicine Button:Regenerate HP.
      * Outdoor Button: Give temporary buff (may trigger temporary debuff)
      * Each button will trigger pet animation
      * Background: Pixel art scene (e.g., a forest or pet arena).
 Transitions:
      * Battle Button clicked then transit to Level Selection Page.
6.2.4. Level Selection Page
  

Purpose: Allows players to choose a battle challenge.
 Components:
      * Level Title: Panel on top, showing the Level Title. 
      * Level Cards: Vertical or grid layout of 3-5 levels.
      * Pet Status: Show the status of pet (e.g. HP, Level, Energy) in pixel text.
      * Level Detail: Shows the details of level (e.g, item drop probability, enemy type)
      * Start Button: Appears below the selected level card.
      * Background: Dynamic pixel art based on level cards(e.g., forest, cave).
 Transitions:
      * Start clicked then transit to Battle Page for the chosen level.

6.2.5. Battle Page
  

Purpose: Turn-based combat interface where players control their pet.
 Components:
         * Battlefield: Split-screen pixel art:
         * Left: Player’s pet sprite (animated idle).
         * Right: Enemy pet sprite (animated idle).
         * Pet Status: Show the battle status of pet (e.g. HP Barl, Energy).
         * Enemy Status: Show the battle status of enemy (e.g. HP Barl, Energy).
         * Turn Menu (Bottom of Screen, buttons label in letters):
         * Attack Button: Basic attack option.
         * Skill Button 1, 2: Special move (e.g., “Fire Breath”).
         * Defend Button: Reduces damage taken.
         * Item Button: Use an item (e.g., potion).
         * Buttons are pixel art icons with text labels on hover.
         * Start Button: Appears below the selected level card.
         * Background: Dynamic pixel art based on level (e.g., forest, cave).
Interactions:
         * Player selects an action → Pet animates (e.g., attack sprite) → AI Enemy responds → Turn ends. (vice versa)
 Transitions:
         * Battle ends (win/lose) then transit to Battle Result Popup.
6.2.6. Battle Result Popup
  

Purpose: Displays the outcome of the battle.
Components:
         * Title: “Victory!” or “Defeat!” in bold pixel font.
         * Battle Result: Show the result and details of battle (e.g. Damage dealt, HP remaining, etc.)
         * Rewards:  List of loot in pixel art icons with text labels on hover below the battle result.
         * Homepage : Button below rewards to close the popup and return to the home page.
         * Background: Semi-transparent overlay over the Battle Page.
Transitions:
         * OK clicked → Returns to Home Page.
6.3. User Interface Design Sample
  

  





         7. Assumptions
Listed below are the assumptions of software and hardware constraints of PetQuest.
         * It is assumed that the size of the game window is fixed throughout the gameplay (even though responsive design is implemented).
         * It is assumed that each player can only own one pet, and players cannot alter their choice of pet.
         * It is assumed that there will be only one login per user at the same time.